const RSMQPromise = require('rsmq-promise');
const logger = require('logger');
const messages = require('./message-formats.json');

const ARTIST_DETAILS = 'artist-details';
const ARTIST_DETAILS_QUEUE = 'artist-details-job';
const ARTIST_DETAILS_ERROR = 'artist-details-error';
const ARTIST_DETAILS_RESPONSE_Q = 'artist-details-job-response';
const SYNC_LIBRARY_QUEUE = 'sync-library-job';
const SYNC_LIBRARY_RESPONSE_Q = 'sync-library-job-response';
const LIBRARY_SYNC = 'library-sync';
const queues = [ARTIST_DETAILS_QUEUE, ARTIST_DETAILS_RESPONSE_Q, ARTIST_DETAILS_ERROR, SYNC_LIBRARY_QUEUE, SYNC_LIBRARY_RESPONSE_Q];

// connect 
const rsmq = new RSMQPromise({  
    host: "127.0.0.1",
    port: 6379
}); 
 
setupQueues(); // initialize

let MessageQueue = {
    
    ARTIST_DETAILS: ARTIST_DETAILS,
    ARTIST_DETAILS_QUEUE: ARTIST_DETAILS_QUEUE,
    ARTIST_DETAILS_ERROR: ARTIST_DETAILS_ERROR,
    ARTIST_DETAILS_RESPONSE_Q: ARTIST_DETAILS_RESPONSE_Q,
    SYNC_LIBRARY_QUEUE: SYNC_LIBRARY_QUEUE,
    SYNC_LIBRARY_RESPONSE_Q: SYNC_LIBRARY_RESPONSE_Q,

    createArtistDetailsJob: (artistId, token, attempt) => {
        if (token)
            logger.info('creating artist details job: ' + artistId + ' and token: ' + token);
        logger.info('creating artist details job: ' + artistId + ' with client authentication.');
        let message = messages[ARTIST_DETAILS];
        message.token = token ? token : undefined; // user token preferred, client supported
        message.artist_id = artistId;
        message.attempt = attempt ? attempt : 0;
        let msgStr = JSON.stringify(message);
        return rsmq.sendMessage({qname: ARTIST_DETAILS_QUEUE, message: msgStr})
            .then((res) => {
                logger.debug('details job sent!');
            });
    },

    consumeArtistDetailsResponse: () => {
        return rsmq.receiveMessage({qname: ARTIST_DETAILS_RESPONSE_Q})
            .then((job) => {
                let msg;
                if (job.message)
                    msg = JSON.parse(job.message);
                return msg;
            });
    },

    consumeArtistDetailsJob: () => {
        return rsmq.receiveMessage({qname: ARTIST_DETAILS_QUEUE})
            .then((job) => {
                let message = JSON.parse(job.message);
                return message;
            });
    },
    
    createArtistDetailsResponse: (details) => {
        logger.debug('creating artist details response with details: ' + JSON.stringify(details));
        let message = messages[ARTIST_DETAILS_RESPONSE_Q];
        message.details = details;
        message.attempt = 0;
        message = JSON.stringify(message);
        return rsmq.sendMessage({qname: ARTIST_DETAILS_RESPONSE_Q, message: message})
            .then((res) => {
                logger.debug('details response sent!');
            })
            .catch((err) => {
                JSON.stringify(err);
            });
    },
    
    consumeArtistDetailsResponse: () => {
        return rsmq.receiveMessage({qname: ARTIST_DETAILS_RESPONSE_Q})
            .then((job) => {
                let msg;
                if (job.message)
                    msg = JSON.parse(job.message);
                return msg;
            });
    },

    deleteQueue: (queueName) => {
        return rsmq.deleteQueue({qname: queueName})
            .then((res) => {
                logger.info(res);
            });
    },

    getQueueSize: (queueName) => {
        return rsmq.getQueueAttributes({qname: queueName})
            .then((results) => {
                return results.msgs;
            })
            .catch((err) => {
                logger.error(err.toString() + ' ' + queueName);
                return -1;
            })
    },

    createLibrarySyncJob: () => {
        // TODO
    },
  
    createScanJob: () => {
        // TODO
    }
};

function setupQueues() {
    logger.info('setting up queues');
    queues.forEach((queue) => {
        logger.info('creating ' + queue + ' if not already exists.');
        rsmq.createQueue({
                qname: queue
            })
            .then((done) => {
                // nada
            })
            .catch((err) => {
                if (err.toString().toLowerCase().indexOf('queue exists') == -1)
                    logger.error(err);
            });
    });
};


module.exports = MessageQueue;